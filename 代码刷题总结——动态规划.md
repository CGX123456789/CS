@[TOC](目录)
# 动态规划
动态规划，简称DP，每一个状态是由之前的状态推导出来的，后面的状态依赖于前面的状态，所以要先计算前面的。所以要计算第n个状态，要从第1个开始计算。
 ## 1.  斐波那契、爬楼梯、矩阵的不同路径、整数拆分、二叉搜索树
 * 一维dp，状态压缩
 * 斐波那契、爬楼梯常规解法就是用斐波那契法。
 * 不同路径总和个数，矩阵从左上走到右下。
 
 		递推公式：dp[i][j] = dp[i - 1][j] + dp[i ][j - 1];
 		要初始化矩阵第一行和第一列。
	```cpp
	class Solution {
	public:
		  int uniquePaths(int m, int n) {
		      vector<vector<int>> dp(m, vector<int>(n, 0));
		      for (int i = 0; i < m; i++) dp[i][0] = 1;
		      for (int j = 0; j < n; j++) dp[0][j] = 1;
		      for (int i = 1; i < m; i++) {
		          for (int j = 1; j < n; j++) {
		              dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
		          }
		      }
		      return dp[m - 1][n - 1];
		  }
	};
	```
 * 不同路径总和个数，矩阵从左上走到右下，含障碍版。
 		
 		递推公式：dp[i][j] = dp[i - 1][j] + dp[i ][j - 1];
 		要初始化矩阵第一行和第一列。
	```cpp
	class Solution {
	public:
	    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
	        int m = obstacleGrid.size();
	        int n = obstacleGrid[0].size();
	        if (obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0;
	        vector<vector<int>> dp(m, vector<int>(n, 0));
	        for (int i = 0; i < m && obstacleGrid[i][0] == 0 ; i++) dp[i][0] = 1;
	        for (int j = 0; j < n && obstacleGrid[0][j] == 0 ; j++) dp[0][j] = 1;
	        for (int i = 1; i < m; i++) {
	           for (int j = 1; j < n; j++) {
	               if(obstacleGrid[i][j] == 0) dp[i][j] = dp[i-1][j] + dp[i][j-1]; 
	           }
	        }
	        return dp[m-1][n-1];
	    }
	};
	```
 * 整数拆分，求乘积最大值。（本题也可以用贪心，每次拆成n个3，如果剩下是4，则保留4，然后相乘。）
 		
 		dp[n]：整数n拆分后，乘积最大值为dp[n]。
 		递推公式：   // 拆1、拆2、拆3......
	                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
	```cpp
	
	class Solution {
	public:
	    int integerBreak(int n) {
	        vector<int> dp(n + 1);
	        dp[2] = 1;
	        for (int i = 3; i <= n ; i++) {
	            for (int j = 1; j <= i / 2; j++) {
	            	// 拆1、拆2、拆3......
	                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
	            }
	        }
	        return dp[n];
	    }
	};
	```
 * 给定一个整数 n，求以 1 ... n 为节点共有多少种不同的二叉搜索树。（二叉搜索树：左＜根＜右 + 子树也满足。）
 		
 		求n个节点时，问题拆分为，以1为头节点有几种，以2为头节点有几种......以n为头节点有几种，累加。
 		dp[n]：以1...n为节点共有n种不同的二叉搜索树。
 		递推公式：dp[i] += dp[j - 1] * dp[i - j];
	```cpp
	class Solution {
	public:
	    int numTrees(int n) {
	        vector<int> dp(n + 1);
	        dp[0] = 1;
	        for (int i = 1; i <= n; i++) {
	            for (int j = 1; j <= i; j++) {
	                dp[i] += dp[j - 1] * dp[i - j];
	            }
	        }
	        return dp[n];
	    }
	};
	```
## 2. 背包问题
01背包：n种物品，每种物品只有一个，也就是每个物品只能使用一次。
完全背包：n种物品，每种物品有无限个，也就是每个物品可以使用无数次。
多重背包：n种物品，每种物品的个数各不相同。
		
		装满这个背包的最大价值、能不能装满、尽可能装，能装多少是多少。	dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
		装满这个背包有多少种方法。	dp[j] += dp[j - nums[i]];
		装满这个背包，最多有多少个物品==最大价值。
		（完全）装满背包最少用多少件物品。	dp[j] = min(dp[j], dp[j - nums[i]] + 1);
### 01背包
 纯01背包：n种物品，每种物品只有一个，每个物品有自己的重量和价值，有一个重量容量为m的背包，问装满背包的最大价值。 （背包不一定装满） 
	暴力解法：回溯算法进行暴力搜索，枚举所有情况，每个物品取与不取。时间复杂度O(2^n^)。
```cpp
二维dp
dp[i][j]：下标[0,i]物品任取，放进容量为j的背包，最大价值为dp[i][j]。
不放物品i：dp[i-1][j]
放物品i：dp[i-1][j-weight[i]] + value[i]
dp[i][j] = max(不放物品i, 放物品i);
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);
1. 先遍历物品，后遍历背包。先遍历背包，后遍历物品。都可以。
2. 先遍历物品，后遍历背包。要初始化矩阵第一行。（上方和左上方要确保有值）


// 二维数组
vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));
// 初始化，初始化第一行即可。
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 这个是为了展现dp数组里元素的变化
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}

01背包一维dp
dp[j]：容量为j的背包，所能装的最大价值为dp[j]。
dp[j] = max(不放物品i, 放物品i);
dp[j] = max(dp[j], dp[j-weight[i]] + value[i]);
1.只能先遍历物品，后遍历背包。
2.且背包倒序。(倒序是因为01背包每个物品只能使用1次)
时间复杂度O(n^2)。
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);//	这个式子默认更新第一行了
    }
}
```
	纯01背包：装满这个背包的最大价值。
	分割数组等和子集：能不能装满这个背包。
	最后一块石头重量：尽量去装，能装多少是多少。
	dp[j]：容量为j的背包，所能装的最大价值为dp[j]。
	dp[0] = 0;
	dp[j] = max(dp[j], dp[j-weight[i]] + value[i]);


	目标和：装满背包有多少种方式。
	dp[j]，装满容量为j的背包，有dp[j]种方法。
	dp[0] = 1;
	dp[j] += dp[j-nums[i]];
	
	
	一和零：装满这个背包，最多有多少个物品。（物品价值为1时，也就是装满这个背包，最大价值。）
	这题比较有特色，用01背包，1维dp的思路，去解决二维dp问题。背包容量是2维的。
	dp[i][j]: 背包容量为i个0，j个1，装满后，物品最大个数为dp[i][j]。
	或者理解为装满后，最大价值为dp[i][j]。每个物品价值为1。
	物品重量为x个0，y个1。物品价值为1。
	dp[0][0] = 0;  
	dp[i][j] = max(dp[i][j], dp[i-x][j-y] + 1);
![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/40c76ea8b5e24e7dbcf821338888efa9.png#pic_center =250x)
* 分割等和子集。求集合里能否出现总和为 sum / 2 的子集。这道题目就是一道01背包应用类的题目，需要我们拆解题目，然后套入01背包的场景。题目中物品是nums[i]，重量是nums[i]，价值也是nums[i]，背包体积是sum/2。
		
		weight[i] = value[i] = nums[i]
		dp[j] = max(dp[j], dp[j-nums[i]] + nums[i]);
		
	```cpp
	class Solution {
	public:
	    bool canPartition(vector<int>& nums) {
	        int sum = 0;
	        for (int i = 0; i < nums.size(); i++) {
	            sum += nums[i];
	        }
	        // 除以2，余数要么是0，要么是1.
	        if(sum % 2 != 0) return false;
	        int target = sum / 2;
	        vector<int> dp(target + 1);
	
	       for (int i = 0; i < nums.size(); i++) {
	           for (int j = target; j >= nums[i]; j--) {
	               dp[j] = max(dp[j], dp[j-nums[i]] + nums[i]);
	           }
	       }
	       if(dp[target] == target) return true;
	       else return false;
	   }
	};
	```
* 最后一块石头的重量。石头相撞，重量相减。
		
		wieght[i] = value[i] = stones[i]。重量==价值。
		递推公式：dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
	```cpp
	class Solution {
	public:
	    int lastStoneWeightII(vector<int>& stones) {
	        int sum = 0;
	        for (int i = 0; i < stones.size(); i++) {
	            sum += stones[i];
	        }
	        int target = sum / 2;
	        vector<int> dp(target+1);
	        for (int i = 0; i < stones.size(); i++) {
	            for (int j = target; j >= stones[i] ; j--)
	                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
	        }
	        return sum - dp[target] -dp[target];
	    }
	};
	```
* 目标和。数组添加+、-，使和等于目标数，求有多少种方法。

		left + right = sum
		left - right = target
		left 即为背包容量。
		装满背包有多少种方式，递推公式：dp[j] += dp[j - nums[i]];
	```cpp
	class Solution {
	public:
	    int findTargetSumWays(vector<int>& nums, int target) {
	        int sum = 0;
	        for (int i =0; i < nums.size(); i++) {
	            sum += nums[i];
	        }
	        if (abs(target) > sum) return 0;
	        if( (target + sum) % 2 != 0) return 0;
	        int bagweight = (target + sum) / 2;
	        vector<int> dp(bagweight + 1);
	        dp[0] = 1;        
	        for (int i = 0; i < nums.size(); i++) {
	            for (int j = bagweight; j >= nums[i]; j--)
	                dp[j] += dp[j -nums[i]];
	        }
	        return dp[bagweight];
	    }
	};	
	```
* 输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
	输出：4
	解释：5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 
		
		递推公式：dp[j][i] = max(dp[j][i], dp[j - zeroNum][i - oneNum] + 1);
		每个物品的价值为1。最大物品个数==最大价值
	```cpp
	class Solution {
	public:
	    int findMaxForm(vector<string>& strs, int m, int n) {
	        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
	        for (string& str : strs) {// 遍历物品
	            int zeroNum = 0, oneNum = 0;
	            for (char& c : str) {
	                if(c == '0') zeroNum++;
	                else oneNum++;
	            }
	            // m 对应 0,  n 对应 1, 先0后1
	            for (int i = n; i >= oneNum; i--) {// 倒序遍历背包
	                for (int j = m; j >= zeroNum; j--) {
	                    dp[j][i] = max(dp[j][i], dp[j - zeroNum][i - oneNum] + 1);
	                }
	            }
	        }
	        return dp[m][n];
	    }
	};
	```
### 完全背包
纯完全背包：n种物品，每种物品可以使用无限次，每个物品有自己的重量和价值，有一个重量容量为m的背包，问装满背包的最大价值。 （背包不一定装满）
	1. 遍历背包时要正序遍历。（正序遍历：每个物品可以使用无限次）
	2. 对于纯完全背包问题，先遍历物品，后遍历背包。先遍历背包，后遍历物品。都可以。
	3. 先遍历物品，后遍历背包。是组合数。
	4. 先遍历背包，后遍历物品。是排列数。
	5. 纯完全背包，要求先用二维dp数组实现，然后再用一维dp数组实现。
```cpp
完全背包二维dp
vector<vector<int>> dp(weight.size(), vector<int>(bagWeight + 1, 0));
   // 遍历物品
   for(int i = 0; i < weight.size(); i++) {
       // 遍历背包容量
       for(int j = 0; j <= bagWeight; j++) {
           if (j < weight[i]) { // 如果背包容量不足以放入当前物品，则只能选择不放入
               dp[i][j] = dp[i - 1][j];
           } else { // 否则，选择放入当前物品 0 到 (j/weight[i]) 次，取最大值
               for (int k = 0; k <= j / weight[i]; k++) {
                   dp[i][j] = max(dp[i][j], dp[i - 1][j - k * weight[i]] + k * value[i]);
               }
           }
       }
   }
   
完全背包一维dp
先遍历物品
for (int i = 0; i < weight.size(); i++) {
	for (int j = weight[i]; j < = bagweight; j++) {
		dp[j] = max(dp[j], dp[j - weight[j]] + value[j]);
	}
}
先遍历背包，二者写法有细微区别。
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
       for(int i = 0; i < weight.size(); i++) { // 遍历物品
           if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
       }
   }
   
纯完全背包：装满这个背包的最大价值。	dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
零钱兑换II：装满这个背包有多少种方法，区分组合排列。	dp[j] += dp[j - nums[i]];
零钱兑换I：装满背包最少用多少件物品。	dp[j] = min(dp[j], dp[j - nums[i]] + 1);
```
* 零钱兑换II，给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。
		
		dp[j] += dp[j -coins[i]];
	```cpp
	装满这个背包有多少种方法，求组合数，元素无序。
	class Solution {
	public:
	    int change(int amount, vector<int>& coins) {
	        vector<int> dp(amount + 1);
	        dp[0] = 1;
	        for (int i = 0; i < coins.size(); i++) {
	            for (int j = coins[i]; j <= amount; j++) {
	                dp[j] += dp[j -coins[i]];
	            }
	        }
	        return dp[amount];
	    }
	};
	```
* 爬楼梯（进阶版）。需要 n 阶，你才能到达楼顶。每次你可以爬 1-m 个台阶。你有多少种不同的方法可以爬到楼顶呢？求排列数。
		
		爬楼梯有两种解法：斐波那契法（常规）+ 完全背包法
		dp[j] += dp[j - i];
	```cpp
	#include <iostream>
	#include <vector>
	using namespace std;
	int main() {
	    int n, m;
	    while (cin >> n >> m) {
	        vector<int> dp(n + 1, 0);
	        dp[0] = 1;
	        for (int i = 1; i <= n; i++) { // 遍历背包
	            for (int j = 1; j <= m; j++) { // 遍历物品
	                if (i - j >= 0) dp[i] += dp[i - j];
	            }
	        }
	        cout << dp[n] << endl;
	    }
	}
	```
* 零钱兑换：求凑成金额所需的最少的硬币个数。而本题是要求最少硬币数量，硬币是组合数还是排列数都无所谓！所以两个for循环先后顺序怎样都可以！
		
		vector<int> dp(amount + 1, INT_MAX);
		注意初始化是INT_MAX、注意初始化是INT_MAX
		递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
	```cpp
	// 版本一
	class Solution {
	public:
	    int coinChange(vector<int>& coins, int amount) {
	        vector<int> dp(amount + 1, INT_MAX);
	        dp[0] = 0;
	        for (int i = 0; i < coins.size(); i++) { // 遍历物品
	            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
	                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过
	                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
	                }
	            }
	        }
	        if (dp[amount] == INT_MAX) return -1;
	        return dp[amount];
	    }
	};
	```
* 一个字符串 s 和 字符串列表 wordDict 作为字典。如果可以利用字典中出现的个单词拼接出 s 则返回 true。本题完全背包，且有序是排列问题。
		
		string tmp = s.substr(起始位置、长度);
	```cpp
	class Solution {
	public:
	    bool wordBreak(string s, vector<string>& wordDict) {
	    //	字符串 s 就是背包
	     // 对字符串 s 从前向后动态规划
	        vector<bool> dp(s.size()+1, false);
	        dp[0] = true;
	        for (int j = 1; j <= s.size(); j++) {   // 遍历背包
	            for (int i = 0; i < wordDict.size(); i++) { // 遍历物体
	                if (wordDict[i].size() <= j) {
	                    string tmp = s.substr(j-wordDict[i].size(), wordDict[i].size());
	                    dp[j] = ( (tmp == wordDict[i]) && dp[j - wordDict[i].size()]);
	                    if (dp[j]) break;
	                }
	            }
	        }
	        return dp[s.size()];
	    }
	};



	class Solution {
	public:
	    bool wordBreak(string s, vector<string>& wordDict) {
	        // unordered_set 是无序的，顺序就是元素放进去的顺序
	        const unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
	        // 对字符串 s 从前向后动态规划
	        vector<bool> dp(s.size()+1, false);
	        dp[0] = true;
	        for (int j = 1; j <= s.size(); j++) {
	            for (int i = 0; i < j; i++) {
	                string word = s.substr(i, j - i);
	                if (wordSet.find(word) != wordSet.end() && dp[i] == true) {
	                    dp[j] = true;
	                    break;
	                }
	            }
	        }
	        return dp[s.size()];
	    }
	};
	```
## 3. 打家劫舍
* 打家劫舍1：相邻房屋不能偷。

		dp[i]：考虑房间下标[0, i]（包含），所能获得的最大金币是dp[i]。
		不偷房间i：dp[i-1]
		偷房间i：nums[i] + dp[i-2]
		递推公式：dp[i] = max(dp[i-1], nums[i] + dp[i-2]);
		初始化：dp[0] = nums[0];	dp[1] = max(nums[0], nums[1]);
	```cpp
	class Solution {
	public:
	    int rob(vector<int>& nums) {
	        if (nums.size() == 0) return 0;
	        if (nums.size() == 1) return nums[0];
	        vector<int> dp(nums.size());
	        dp[0] = nums[0];
	        dp[1] = max(nums[0], nums[1]);
	        for (int i = 2; i < nums.size(); i++) {
	            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
	        }
	        return dp[nums.size() - 1];
	    }
	};
	```
* 打家劫舍2：房屋首尾相连，相邻房屋不能偷。难点就是成环了。
		
		此题和打家劫舍1线性数组的唯一差别是首尾房间不能同时偷，所以可以分成两种情况。
		1: 首房间不偷
		2: 尾房间不偷
		不需要考虑第三种情况了。
	```cpp
	class Solution {
	public:
	    int rob(vector<int>& nums) {
	        if (nums.size() == 0) return 0;
	        if (nums.size() == 1) return nums[0];
	        int result1 = robRange(nums, 0, nums.size() - 2); // 尾房间不偷
	        int result2 = robRange(nums, 1, nums.size() - 1); // 首房间不偷
	        return max(result1, result2);
	    }
	    // 198.打家劫舍的逻辑
	    // 共用同一个nums,而不是使用substr来生成新的，效率更高
	    int robRange(vector<int>& nums, int start, int end) {
	        if (end == start) return nums[start];
	        vector<int> dp(nums.size());
	        dp[start] = nums[start];
	        dp[start + 1] = max(nums[start], nums[start + 1]);
	        for (int i = start + 2; i <= end; i++) {
	            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
	        }
	        return dp[end];
	    }
	};
	```
* 打家劫舍3：树形dp，相邻房屋不能偷。
		
		树形dp：本质上是动态规划，仍是后面状态依赖于前面状态。在树上去遍历，也是有前后顺序的。
		动态规划 + 树的递归遍历
		dp[0]：当前节点不偷，最大金额为dp[0]
		dp[1]：当前节点偷，最大金额为dp[1]
		
		1. 确定递归函数的参数和返回值
		2. 确定终止条件
		3. 确定遍历顺序
	```cpp
	class Solution {
	public:
	    int rob(TreeNode* root) {
	        vector<int> result = robTree(root);
	        return max(result[0], result[1]);
	    }
	    // 长度为2的数组，0：不偷，1：偷
	    vector<int> robTree(TreeNode* cur) {
	        if (cur == NULL) return vector<int>{0, 0};
	        vector<int> left = robTree(cur->left);
	        vector<int> right = robTree(cur->right);
	        // 偷cur，那么就不能偷左右节点。
	        int val1 = cur->val + left[0] + right[0];
	        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
	        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
	        return {val2, val1};
	    }
	};
	时间复杂度：每个节点只遍历了一次，O(n)
	空间复杂度：O(log n)，算上递推系统栈的空间
	
	// vector<int> {0, 0}; 和 vector<int> (0, 0);区别
	// vector<bool> dp(s.size()+1, false);
	// vector<bool> dp(元素个数, 每个元素的值);
	```

## 4. 股票问题
1. 二维dp，dp[ 第几天 ][ 持有、不持有股票 ]
2. 第i天最大金额 = max(前一天就是这个状态，前一天不是这个状态且今天才变成这个状态);	
	==只考虑前一天和今天状态。==
3. dp[i]只是依赖于dp[i - 1]的状态，可以使用滚动数组来节省空间。
4. 只有一只股票，你必须在再次购买前出售掉之前的股票。
		
		只能买卖一次：
								dp[i][0]:第i天持有
								dp[i][1]:第i天 不持有
		可以买卖多次：
								dp[i][0]:第i天持有
								dp[i][1]:第i天 不持有
		至多买卖两次：
								dp[i][0]:第i天 第一次 持有这支股票
								dp[i][1]:第i天 第一次 不持有这支股票
								dp[i][2]:第i天 第二次 持有这支股票
								dp[i][3]:第i天 第二次 不持有这支股票
		至多买卖k次 ：for迭代k次
		可以买卖多次，含冷冻期：
								dp[i][0]：第i天，持有股票状态
								dp[i][1]：第i天，不持有股票状态（不含卖出当天，不含冷冻期）
								dp[i][2]：第i天，当天卖出股票状态
								dp[i][3]：第i天，为冷冻期
		可以买卖多次，含手续费：同1、2
* 买卖股票的最佳时机1：只有一只股票，只能买卖一次。
		
		二维dp：
					dp[i][0]:第i天 不 持有这支股票，最大现金dp[i][0]
					dp[i][1]:第i天持有这支股票，最大现金dp[i][1]
		递推公式：
					dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
        			dp[i][1] = max(dp[i-1][1], 0 - prices[i]);只卖买一次
        从递推公式可以看出，dp[i]只是依赖于dp[i - 1]的状态。
        那么我们只需要记录当前天的dp状态和前一天的dp状态就可以了，可以使用滚动数组来节省空间。
	```cpp
	class Solution {
	public:
	    int maxProfit(vector<int>& prices) {
	        if (prices.size() == 1) return 0;
	        vector<vector<int>> dp(prices.size(), vector<int>{0,0});
	        // dp[i][0], 不持有
	        // dp[i][1], 持有
	        dp[0][0] = 0;
	        dp[0][1] = -prices[0];
	        for (int i = 1; i < prices.size(); i++) {
	            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
	            dp[i][1] = max(dp[i-1][1], 0 - prices[i]);
	        }
	        return dp[prices.size() - 1][0];
	    }
	};
	```
* 买卖股票的最佳时机2：只有一只股票，可以买卖多次。
		
		二维dp：
					dp[i][0]:第i天 不 持有这支股票，最大现金dp[i][0]
					dp[i][1]:第i天持有这支股票，最大现金dp[i][1]
		递推公式：
					dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
        			dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
 *  买卖股票的最佳时机3：至多买卖两次。关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。
 		
 		二维dp：先持有，才可以有不持有。
					dp[i][0]:第i天 不操作，完全未买未卖过，最大现金dp[i][0]
					dp[i][1]:第i天 第一次 持有这支股票，最大现金dp[i][1]
					dp[i][2]:第i天 第一次 不 持有这支股票，最大现金dp[i][2]
					dp[i][3]:第i天 第二次 持有这支股票，最大现金dp[i][3]
					dp[i][4]:第i天 第二次 不 持有这支股票，最大现金dp[i][4]
		递推公式：
					dp[i][0] = dp[i-1][0];
        			dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
        			dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]);        			
        			dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]);        			
        			dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]);
        
        其实我们可以不设置，‘0. 没有操作’ 这个状态，因为没有操作，手上的现金自然就是0。
        正如我们在 121.买卖股票的最佳时机 (opens new window)
        和 122.买卖股票的最佳时机II (opens new window)也没有设置这一状态是一样的。
		二维dp：先持有，才可以有不持有。
					dp[i][0]:第i天 第一次 持有这支股票，最大现金dp[i][1]
					dp[i][1]:第i天 第一次 不 持有这支股票，最大现金dp[i][2]
					dp[i][2]:第i天 第二次 持有这支股票，最大现金dp[i][3]
					dp[i][3]:第i天 第二次 不 持有这支股票，最大现金dp[i][4]
		递推公式：
					dp[i][0] = max(dp[i-1][0], 0 - prices[i]);
					dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);        			
					dp[i][2] = max(dp[i-1][2], dp[i-1][1] - prices[i]);        			
					dp[i][3] = max(dp[i-1][3], dp[i-1][2] + prices[i]);
		  从递推公式可以看出，dp[i]只是依赖于dp[i - 1]的状态。
		  那么我们只需要记录当前天的dp状态和前一天的dp状态就可以了，可以使用滚动数组来节省空间。
	```cpp
	class Solution {
	public:
	    // 数组的大小可以是1,同一天可以买卖多次。
	    int maxProfit(vector<int>& prices) {
	        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
	        dp[0][0] = 0;
	        dp[0][1] = -prices[0]; 
	        dp[0][2] = 0;
	        dp[0][3] = -prices[0];
	        dp[0][4] = 0;
	        for (int i = 1; i < prices.size(); i++) {
	            dp[i][0] = dp[i-1][0];
	            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
	            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]);        			
	            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]);
	            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]);
	        }
	        // return max(dp[prices.size() - 1][0], dp[prices.size() - 1][2], dp[prices.size() - 1][4]);
	        // return max(dp[prices.size() - 1][2], prices.size() - 1][4]);
	        return dp[prices.size() - 1][4];
	    }
	};
	```
* 买卖股票的最佳时机4：至多买卖k次。
		
		dp[i][2*k -1]：第 i 天 第 k 次 持有这支股票，最大现金dp[i][2*k -1]
		dp[i][2*k]：第 i 天 第 k 次 不持有这支股票，最大现金dp[i][2*k]
		用for循环来遍历递推公式即可
		从递推公式可以看出，dp[i]只是依赖于dp[i - 1]的状态。
		那么我们只需要记录当前天的dp状态和前一天的dp状态就可以了，可以使用滚动数组来节省空间。
	```cpp
	class Solution {
	public:
	    int maxProfit(int k, vector<int>& prices) {
	        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
	        for (int j = 1; j <= k ; j++) {
	            dp[0][2 * j - 1] = -prices[0];
	            dp[0][2 * j] = 0;
	        }
	        for (int i = 1; i < prices.size(); i++) {
	            for (int j = 1; j <= k; j++) {
	                dp[i][2 * j - 1] = max(dp[i - 1][2 * j - 1], dp[i - 1][2 * j - 2] - prices[i]);
	                dp[i][2 * j] = max(dp[i - 1][2 * j], dp[i - 1][2 * j - 1] + prices[i]);
	            }
	        }
	        return dp[prices.size() -1][2 * k];
	    }
	};
	```
* 买卖股票的最佳时机，有冷冻期：可买卖多次，卖出股票那一天的下一天，为冷冻期1天。
		
		dp[i][0]：第i天，持有股票状态，最大金额dp[i][0]。
		dp[i][1]：第i天，不持有股票状态（不含卖出当天，不含冷冻期），最大金额dp[i][1]。
		dp[i][2]：第i天，当天卖出股票状态，最大金额dp[i][2]。
		dp[i][3]：第i天，为冷冻期，最大金额dp[i][3]。
		dp[i][1] 和 dp[i][2] 和 dp[i][3]，合计为不持有股票状态。
		dp[i][0] = max(dp[i-1][0], max(dp[i-1][1] - prices[i], dp[i-1][3] - prices[i]));
		dp[i][1] = max(dp[i-1][1], dp[i-1][3]);
		dp[i][2] = max(dp[i-1][2], dp[i-1][0] + prices[i]);错误，必须当天卖。
		dp[i][2] = dp[i-1][0] + prices[i];
		dp[i][3] = max(dp[i-1][3], dp[i-1][2]);错误，前一天为冷冻期，今天不可能为冷冻期。
		dp[i][3] = dp[i-1][2];
		从递推公式可以看出，dp[i]只是依赖于dp[i - 1]的状态。
		那么我们只需要记录当前天的dp状态和前一天的dp状态就可以了，可以使用滚动数组来节省空间

	```cpp
	class Solution {
	public:
	    int maxProfit(vector<int>& prices) {
	        vector<vector<int>> dp(prices.size(), vector<int>(4, 0));
	        dp[0][0] = -prices[0];
	        dp[0][1] = 0;
	        dp[0][2] = 0;
	        dp[0][3] = 0;
	        for (int i = 1; i < prices.size(); i++) {
	            dp[i][0] = max(dp[i-1][0], max(dp[i-1][1] - prices[i], dp[i-1][3] - prices[i]));
	            dp[i][1] = max(dp[i-1][1], dp[i-1][3]);
	            dp[i][2] = dp[i-1][0] + prices[i];
	            dp[i][3] = dp[i-1][2];
	        }
	        return max(dp[prices.size() - 1][3], max(dp[prices.size() - 1][1], dp[prices.size() - 1][2]));
	    }
	};
	```
* 买卖股票的最佳时机，有手续费：可买卖多次
		
		dp[i][0]:第i天  持有这支股票，最大现金dp[i][0]
		dp[i][1]:第i天 不 持有这支股票，最大现金dp[i][1]
		dp[i][0] = max(dp[i-1][0], dp[i-1][1] -prices[i]);
		dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] -fee);
## 5. 子序列问题
	最长递增子序列：
		dp[i]：以i为结尾，最长递增子序列的长度为dp[i]。
	最长连续递增子序列：
		dp[i]：以i为结尾，最长连续递增子序列的长度为dp[i]。
	最大子数组和：求数组最大连续子序列和。
		dp[i]：以下标i为结尾，最大连续子序列和为dp[i]。

	以下为两个字串问题：二维dp。
	最长连续重复子数组：
		dp[i][j]：nums1以i -1为结尾，nums2以j-2为结尾，最长连续重复子数组的长度为dp[i][j]。
	最长公共子序列：
		dp[i][j]：nums1中取[0, i -1]，nums2中取[0, j - 1]，这两个范围中最长公共子序列的长度为dp[i][j]。
	不相交的线：同最长公共子序列。
	判断s是否是t的子序列：同最长公共子序列，求出最长公共子序列的长度，和s长度比较即可。
	t中有多少个s这种的子序列：
		不同于最长公共子序列，[0, j-1]的s是必须取满的，必须取整个。
		dp[i][j]：t取[0, i-1]，s取[0, j-1]，t中含有s的子序列的个数为dp[i][j]。
	两个字符串的删除操作：使其相同，求最少删除操作次数。
		dp[i][j]：字符串1取[0, i-1]，字符串2取[0, j-1]，最少删除操作次数为dp[i][j]。
		解法二：同最长公共子序列。
	编辑距离：求最少操作次数。
		dp[i][j]：字符串1取[0, i-1]，字符串2取[0, j-1]，最少操作次数为dp[i][j]。
	回文子串个数：连续
		dp[i][j]：i为首，j为结尾，是否是回文子串。
	最长回文子序列：不连续，求最长的长度。
		dp[i][j]：[i, j]范围内的子串，最长回文子序列长度为dp[i][j]。
	

最长递增子序列：
		
	dp[i]：以i为结尾，最长递增子序列的长度为dp[i]。
	if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
	用j遍历i的每一个元素
最长连续递增子序列：
		
	dp[i]：以i为结尾，最长连续递增子序列的长度为dp[i]。
	if (nums[i] > nums[i-1]) dp[i] = dp[i-1] + 1;
最长连续重复子数组（两个数组，二维dp）：
		
	dp[i][j]：nums1以i为结尾，nums2以j为结尾，最长连续重复子数组的长度为dp[i][j]。
	需要初始化二维矩阵数组第一行和第一列。
	if (nums1[i] == nums2[j]) dp[i][j] = dp[i-1][j-1] + 1;
	
	dp[i][j]：nums1以i-1为结尾，nums1以j-1为结尾，最长连续重复子数组的长度为dp[i][j]。
	不需要初始化二维矩阵数组第一行和第一列。
	if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
最大子数组和：求数组最大连续子序列和。
		
	dp[i]：以下标i为结尾，最大连续子序列和为dp[i]。
	dp[i] = max(延续前面，不延续了从当前重新开始));
	dp[i] = max(dp[i - 1] + nums[i], nums[i]);
最长公共子序列（两个数组，二维dp）：
		
	dp[i][j]：nums1中取[0, i]，nums2中取[0, j]，这两个范围中最长公共子序列的长度为dp[i][j]。
	if (nums1[i] == nums2[j]) dp[i][j] = dp[i-1][j-1] + 1;
	else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
	
	dp[i][j]：nums1中取[0, i - 1]，nums2中取[0, j -1]，这两个范围中最长公共子序列的长度为dp[i][j]。
	还是这种好，不用初始化。
	if (text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
    else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
不相交的线：同最长公共子序列。
判断s是否是t的子序列：同最长公共子序列，求出最长公共子序列的长度，和s长度比较即可。
		
	dp[i][j]：nums1取[0, i - 1]，nums2取[0, j - 1]，最长公共子序列长度为dp[i][j]。
	s不用删减
	if (text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
    else dp[i][j] = dp[i][j - 1];
t中有多少个s这种的子序列：不连续即可。

	不同于最长公共子序列，[0, j-1]的s是必须取满的，必须取整个
 	dp[i][j]：t取[0, i-1]，s取[0, j-1]，t中含有s的子序列的个数为dp[i][j]。
 	if (s[i-1] == t[j-1]) dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
 	else dp[i][j] = dp[i-1][j];
 	相等时可以使用t的最后一位，也可以不使用。但s必须使用。
 	不相等时，不使用t的最后一位。但s必须使用。
 
 两个字符串的删除操作：使其相同，求最少删除操作次数。

	dp[i][j]：字符串1取[0, i-1]，字符串2取[0, j-1]，最少删除操作次数为dp[i][j]。
	if (t[i - 1] == s[j - 1]) dp[i][j] = dp[i - 1][j - 1];
    else dp[i][j] = min(dp[i-1][j] + 1, dp[i][j - 1] + 1, dp[i-1][j-1] + 2); 
    或者是
    else dp[i][j] = min(dp[i-1][j] + 1, dp[i][j - 1] + 1);
    dp[0][0] = 0;
    dp[i][0] = i;
    dp[0][j] = j;
    
	第二种思路：先求最长公共子序列，删除公共子序列之外的元素就是最少删除操作次数
编辑距离：求最少操作次数。
		
	dp[i][j]：字符串1取[0, i-1]，字符串2取[0, j-1]，最少操作次数为dp[i][j]。
	if (t[i - 1] == s[j - 1]) dp[i][j] = dp[i - 1][j - 1];
	else dp[i][j] = min(dp[i-1][j] + 1, dp[i][j - 1] + 1, dp[i-1][j-1] + 1); 
* 最长递增子序列
		
		dp[i]：以i为结尾，最长递增子序列的长度为dp[i]。
		if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
		用j遍历i的每一个元素
		至少长度为1，每一个dp[i]初始化为1。
	```cpp
	class Solution {
	public:
	    int lengthOfLIS(vector<int>& nums) {
	        if (nums.size() <= 1) return nums.size();
	        vector<int> dp(nums.size(), 1);
	        int result = 1;
	        for (int i = 1; i <nums.size(); i++) {
	            for (int j = 0; j <= i; j++) {
	                if (nums[i] > nums[j]) {
	                    dp[i] = max(dp[i], dp[j] + 1);
	                }
	            }
	            result = max(result, dp[i]);
	        }
	        return result;
	    }
	};
	```

* 最长连续递增子序列
		
		dp[i]：以i为结尾，最长连续递增子序列的长度为dp[i]。
		if (nums[i] > nums[i-1]) dp[i] = dp[i-1] + 1;
		至少长度为1，每一个dp[i]初始化为1。
	```cpp
	class Solution {
	public:
	    int findLengthOfLCIS(vector<int>& nums) {
	        if (nums.size() <= 1) return nums.size();
	        int result = 1;
	        vector<int> dp(nums.size(), 1);
	        for (int i = 1; i < nums.size(); i++) {
	            if (nums[i] > nums[i - 1]) {
	                dp[i] = dp[i - 1] + 1;
	            }
	            result = max(result, dp[i]);
	        }
	        return result;
	    }
	};
	```
* 最长连续重复子数组
		
		dp[i][j]：nums1以i为结尾，nums2以j为结尾，最长连续重复子数组的长度为dp[i][j]。
		if (nums1[i] == nums2[j]) dp[i][j] = dp[i-1][j-1] + 1;
		需要初始化二维矩阵数组第一行和第一列
		

		dp[i][j]：nums1以i-1为结尾，nums1以j-为结尾，最长连续重复子数组的长度为dp[i][j]。
		if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;

		优点：不需要初始化二维矩阵数组第一行和第一列
	```cpp
	class Solution {
	public:
	    int findLength(vector<int>& nums1, vector<int>& nums2) {
	        int result = 0;
	        vector<vector<int>> dp(nums1.size(), vector<int>(nums2.size(), 0));
	        for (int i = 0; i < nums1.size(); i++) {
	            if (nums1[i] == nums2[0]) {
	                dp[i][0] = 1;
	                result = 1;
	            }
	        }
	        for (int j = 0; j < nums2.size(); j++) {
	            if (nums2[j] == nums1[0]) {
	                dp[0][j] = 1;
	                result = 1;
	            }
	        }
	        for (int i = 1; i < nums1.size(); i++) {
	            for (int j = 1; j < nums2.size(); j++) {
	                if (nums1[i] == nums2[j]) dp[i][j] = dp[i - 1][j - 1] + 1;
	                result = max(result, dp[i][j]);
	            }
	        }
	        return result;
	    }
	};
	
	
	class Solution {
	public:
	    int findLength(vector<int>& nums1, vector<int>& nums2) {
	        vector<vector<int>> dp (nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
	        int result = 0;
	        for (int i = 1; i <= nums1.size(); i++) {
	            for (int j = 1; j <= nums2.size(); j++) {
	                if (nums1[i - 1] == nums2[j - 1]) {
	                    dp[i][j] = dp[i - 1][j - 1] + 1;
	                }
	                result = max(result, dp[i][j]);
	            }
	        }
	        return result;
	    }
	};
	```
* 最长公共子序列：不连续即可，但要保证元素顺序。
		
		dp[i][j]：nums1以i为结尾，nums2以j为结尾，最长公共子序列的长度为dp[i][j]。需要对第一行第一列初始化
		if (nums1[i] == nums2[j]) dp[i][j] == max(dp[i][j], dp[m][n] + 1);
		用m遍历i的每一个元素
		用n遍历j的每一个元素
		最终结果存在最大值result
		dp[i][j]：nums1以i-1为结尾，nums2以j-1为结尾，最长公共子序列的长度为dp[i][j]。不需要对第一行第一列初始化。
		if (nums1[i -1] == nums2[j - 1]) dp[i][j] == max(dp[i][j], dp[m][n] + 1);
		

		dp[i][j]：nums1中取[0, i]，nums2中取[0, j]，这两个范围中最长公共子序列的长度为dp[i][j]。
		if (nums1[i] == nums2[j]) dp[i][j] = dp[i-1][j-1] + 1;
		else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
		最终结果存在dp[nums1.size()-1][nums2.size()-1]
		
		
		dp[i][j]：nums1中取[0, i - 1]，nums2中取[0, j -1]，这两个范围中最长公共子序列的长度为dp[i][j]。
		还是这种好，不用初始化。
		if (text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
        else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
	```cpp
	// 法一，超时
	class Solution {
	public:
	// dp[i][j]：nums1以i为结尾，nums2以j为结尾，最长公共子序列的长度为dp[i][j]。
	// if (nums1[i] == nums2[j]) dp[i][j] == max(dp[i][j], dp[m][n] + 1);
	// 用m遍历i的每一个元素
	// 用n遍历j的每一个元素
	// 最终结果存在最大值result
	// 需要对第一行第一列初始化
	    int longestCommonSubsequence(string text1, string text2) {
	        vector<vector<int>> dp(text1.size(), vector<int>(text2.size(), 0));
	        int result = 0;
	        for (int i = 0; i < text1.size(); i++) {
	            if (text1[i] == text2[0]) {
	                result = 1;
	                dp[i][0] = 1;
	            }
	        }
	        for (int j = 0; j < text2.size(); j++) {
	            if (text1[0] == text2[j]) {
	                result = 1;
	                dp[0][j] = 1;
	            }
	        }
	        for (int i = 0; i < text1.size(); i++) {
	            for (int j = 0; j < text2.size(); j++) {
	                if (text1[i] == text2[j]) {
	                    for (int m = 0; m < i; m++) {
	                        for (int n = 0; n < j; n++) {
	                            dp[i][j] = max(dp[i][j], dp[m][n] + 1);
	                        }
	                    }
	                }
	                result = max(result, dp[i][j]);
	            }
	        }
	        return result;
	    }
	};
	class Solution {
	public:
	// dp[i][j]：nums1以i-1为结尾，nums2以j-1为结尾，最长公共子序列的长度为dp[i][j]。
	// if (nums1[i] == nums2[j]) dp[i][j] == max(dp[i][j], dp[m][n] + 1);
	// 用m遍历i的每一个元素
	// 用n遍历j的每一个元素
	// 最终结果存在最大值result
	// 不需要对第一行第一列初始化
	    int longestCommonSubsequence(string text1, string text2) {
	        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
	        int result = 0; // result 必须显示初始化。
	        for (int i = 1; i <= text1.size(); i++) {
	            for (int j = 1; j <= text2.size(); j++) {
	                if (text1[i - 1] == text2[j - 1]) {
	                    for (int m = 0; m < i; m++) {
	                        for (int n = 0; n < j; n++) {
	                            dp[i][j] = max(dp[i][j], dp[m][n] + 1);
	                        }
	                    }
	                }
	                result = max(result, dp[i][j]);
	            }
	        }
	        return result;
	    }
	};
	
	
	// 法二
	class Solution {
	public:
	    int longestCommonSubsequence(string text1, string text2) {
	        vector<vector<int>> dp(text1.size(), vector<int>(text2.size(), 0));
	        // 要特别注意初始化，和以往不一样。
	        // dp[i][0] = text1[i] == text2[0] ? 1 : dp[i - 1][0];
	        if (text1[0] == text2[0]) dp[0][0] = 1;
	        for (int i = 1; i < text1.size(); i++) {
	            dp[i][0] = text1[i] == text2[0] ? 1 : dp[i - 1][0];
	        }
	        for (int j = 1; j < text2.size(); j++) {
	            dp[0][j] = text1[0] == text2[j] ? 1 : dp[0][j - 1];
	        }
	        for (int i = 1; i < text1.size(); i++) {
	            for (int j = 1; j < text2.size(); j++) {
	                if (text1[i] == text2[j]) 
	                    dp[i][j] = dp[i - 1][j - 1] + 1;
	                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
	            }
	        }
	        return dp[text1.size() - 1][text2.size() - 1];
	    }
	};

	//法三
	class Solution {
	public:
	    int longestCommonSubsequence(string text1, string text2) {
	        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
	        // dp[i][j]：nums1中取[0, i - 1]，nums2中取[0, j - 1]
	        for (int i = 1; i <= text1.size(); i++) {
	            for (int j = 1; j <= text2.size(); j++) {
	                if (text1[i - 1] == text2[j - 1]) 
	                    dp[i][j] = dp[i - 1][j - 1] + 1;
	                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
	            }
	        }
	        return dp[text1.size()][text2.size()];
	    }
	};
	```
* 不相交的线：同最长公共子序列
* 最大子数组和：求数组最大连续子序列和
		
		dp[i]：以下标i为结尾，最大连续子序列和为dp[i]。
		dp[i] = max(延续前面，不延续了从当前重新开始);
		dp[i] = max(dp[i-1] + nums[i], nums[i]);
		dp[0] = nums[0];

		此外，本题还可以用暴力解法和贪心的思路来解决。
	```cpp
	class Solution {
	public:
	    int maxSubArray(vector<int>& nums) {
	        vector<int> dp(nums.size(), 0);
	        dp[0] = nums[0];
	        int result = nums[0];
	        // dp[i]:以i结尾的,最大连续子序列和为dp[i]。
	        for (int i = 1; i < nums.size(); i++) {
	            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
	            result = max(result, dp[i]);
	        }
	        return result;
	    }
	};


	滚动数组优化：
	class Solution {
	public:
	    int maxSubArray(vector<int>& nums) {
	        int dp0 = nums[0], dp1 = 0;
	        int result = nums[0];
	        // dp[i]:以i结尾的,最大连续子序列和为dp[i]。
	        for (int i = 1; i < nums.size(); i++) {
	            dp1 = max(dp0+ nums[i], nums[i]);
	            result = max(result, dp1);
	            dp0 = dp1;
	        }
	        return result;
	    }
	}
	```
* 判断s是否是t的子序列：同最长公共子序列
		
		dp[i][j]：nums1取[0, i - 1]，nums2取[0, j - 1]，最长公共子序列长度为dp[i][j]。
		if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
		else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
		或者这里是如下，s不删元素，t删元素。因为要确保s计算满。
		else dp[i][j] = dp[i][j - 1];

		本题还可以用双指针法
	```cpp
	不需要初始化版本，好处不光不用初始化，而且不用判断是否为空。
	class Solution {
	public:
	    bool isSubsequence(string s, string t) {
	        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
	        for (int i = 1; i <= s.size(); i++) {
	            for (int j = 1; j <= t.size(); j++) {
	                if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
	                // else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
	                else dp[i][j] = dp[i][j - 1];
	            }
	        }
	        return dp[s.size()][t.size()] == s.size();
	    }
	};

	需要初始化版本
	class Solution {
	public:
	    bool isSubsequence(string s, string t) {
	        if (s == "") return true;
	        if (t == "") return false;
	        vector<vector<int>> dp(s.size(), vector<int>(t.size(), 0));
	        dp[0][0] = (s[0] == t[0] ? 1 : 0);
	        for (int i = 1; i < s.size(); i++) {
	            dp[i][0] = s[i] == t[0] ? 1 : dp[i - 1][0];
	        }
	        for (int j = 1; j < t.size(); j++) {
	            dp[0][j] = s[0] == t[j] ? 1 : dp[0][j - 1];
	        }
	        for (int i = 1; i < s.size(); i++) {
	            for (int j = 1; j < t.size(); j++) {
	                if (s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1] + 1;
	                // else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
	                else dp[i][j] = dp[i][j - 1];
	            }
	        }
	        return dp[s.size() - 1][t.size() - 1] == s.size();
	    }
	};
	```
* t中有多少个s这种的子序列：不连续即可。
	==不同于最长公共子序列，[0, j-1]的s是必须取满的，必须取整个==
		
		dp[i][j]：t取[0, i-1]，s取[0, j-1]，t中含有s的子序列的个数为dp[i][j]。
		if (s[i-1] == t[j-1]) dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
		else dp[i][j] = dp[i-1][j];
		相等时，dp[i][j] = t用最后一个数字 + t不用最后一个数字      s肯定要用

		初始化：dp[i][0] = 1; dp[0][j] = 0; dp[0][0] = 1;
		这里初始化和之前的最长公共子序列问题不一样了。
	```cpp
	class Solution {
	public:
	    int numDistinct(string s, string t) {
	        // s取[0, i-1]
	        // t取[0, j-1]
	        vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1, 0));
	        // 初始化
	        // dp[0][j] = 0;
	        // dp[i][0] = 1;
	        // dp[0][0] = 1;
	        for (int i = 0; i <= s.size(); i++) {
	            dp[i][0] = 1;
	        }
	        for (int i = 1; i <= s.size(); i++) {
	            for (int j = 1; j <= t.size(); j++) {
	                if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
	                else dp[i][j] = dp[i - 1][j];
	            }
	        }
	        return dp[s.size()][t.size()];
	    }
	};
	```
* 两个字符串的删除操作：使其相同，求最少删除操作次数。
		
		dp[i][j]：字符串1取[0, i-1]，字符串2取[0, j-1]，最少删除操作次数为dp[i][j]。
		if (t[i - 1] == s[j - 1]) dp[i][j] = dp[i - 1][j - 1];
		else dp[i][j] = min(dp[i-1][j] + 1, dp[i][j - 1] + 1, dp[i-1][j-1] + 2); 
		或者是
		else dp[i][j] = min(dp[i-1][j] + 1, dp[i][j - 1] + 1);
		dp[0][0] = 0;
		dp[i][0] = i;
		dp[0][j] = j;

		第二种思路：先求最长公共子序列，删除公共子序列之外的元素就是最少删除操作次数。
	```cpp
	dp[i][j]：字符串1取[0, i-1]，字符串2取[0, j-1]，最少删除操作次数为dp[i][j]
	class Solution {
	public:
	    int minDistance(string word1, string word2) {
	        // dp[i][j]：字符串1取[0, i-1]，字符串2取[0, j-1]，最少删除操作次数为dp[i][j]。
	        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
	        // dp[0][0] = 0;
	        // dp[0][j] = j;
	        // dp[i][0] = i;
	        for (int i = 1; i <= word1.size(); i++) {
	            dp[i][0] = i;
	        }
	        for (int j = 1; j <= word2.size(); j++) {
	            dp[0][j] = j;
	        }
	        for (int i = 1; i <= word1.size(); i++) {
	            for (int j = 1; j <= word2.size(); j++) {
	                if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
	                else dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i -1][j - 1] + 2));
	            }
	        }
	        return dp[word1.size()][word2.size()];
	    }
	};
	最长公共子序列：
	class Solution {
	public:
	    int minDistance(string word1, string word2) {
	        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
	        // dp[0][0] = 0;
	        // dp[0][j] = 0;
	        // dp[i][0] = 0;
	        for (int i = 1; i <= word1.size(); i++) {
	            for (int j = 1; j <= word2.size(); j++) {
	                if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
	                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
	            }
	        }
	        return word1.size() + word2.size() - 2 * dp[word1.size()][word2.size()];
	    }
	};
	```
* 编辑距离：求最少操作次数。
		
		dp[i][j]：字符串1取[0, i-1]，字符串2取[0, j-1]，最少操作次数为dp[i][j]。
		if (word[i - 1] == word2[j - 1]) dp[i][j] =dp[i - 1][j - 1] ;
		else dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2, dp[i - 1][j - 1] + 1) ;
		else dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1) ;
		不相同的时候分为：增加、删除、替换。增加、删除属于一种操作。
		删除：dp[i - 1][j] + 1, dp[i][j - 1] + 1
		替换：dp[i - 1][j - 1] + 1 
		dp[0][0] = 0;
		dp[0][j] = j;
		dp[i][0] = i;

		求最少删除操作次数：
		if (word[i - 1] == word2[j - 1]) dp[i][j] =dp[i - 1][j - 1] ;
		else dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 2) ;
		求最少操作次数
		if (word[i - 1] == word2[j - 1]) dp[i][j] =dp[i - 1][j - 1] ;
		else dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1) ;
		删除需要2次，但替换只需要1次
	```cpp
	class Solution {
	public:
	    int minDistance(string word1, string word2) {
	        // dp[i][j]：字符串1取[0, i-1]，字符串2取[0, j-1]，最少操作次数为dp[i][j]。
	        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
	        // dp[0][0] = 0;
	        // dp[0][j] = j;
	        // dp[i][0] = i;
	        for (int i = 1; i <= word1.size(); i++) {
	            dp[i][0] = i;
	        }
	        for (int j = 1; j <= word2.size(); j++) {
	            dp[0][j] = j;
	        }
	        for (int i = 1; i <= word1.size(); i++) {
	            for (int j = 1; j <= word2.size(); j++) {
	                if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
	                else dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i -1][j - 1] + 1));
	                // 和最少删除操作次数，仅仅这里不一样。
	            }
	        }
	        return dp[word1.size()][word2.size()];
	
	    }
	};
	```
* 回文字串：回文串：从中间开始，左右两边是对称的。==本题要求连续。==
		
		dp[i][j]：i为首，j为结尾，是否是回文串、存储bool。
		若是定义成回文字串的个数，是行不通的。
		if (s[i] == s[j]) {
		 		if (j - i <= 1) { dp[i][j] = true; result++; }
		 		else if (dp[i + 1][j - 1] == true) {dp[ij][j] = true; result++;}
		}
		当前位置是由左下角推出来的。  
		所以i从下往上，j从左往右去遍历。
		表格只有右上方有数据。

		本题另一解法：双指针。一个for循环去遍历字符串里面每一个元素。
		以每一个元素为中间节点，再有一个while循环向四周扩散，统计有多少回文串。
	```cpp
	class Solution {
	public:
	    int countSubstrings(string s) {
	    // dp[i][j]：i为首，j为结尾，是否是回文串，是否是回文串。
	        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
	        int result = 0;
	        for (int i = s.size() - 1; i >= 0; i--) {
	            for (int j = i; j < s.size(); j++) {
	                if (s[i] == s[j]) {
	                    if (j - i <= 1) {
	                        dp[i][j] = true;
	                        result++;
	                    }
	                    else if (dp[i + 1][j - 1] == true){
	                        dp[i][j] = true;
	                        result++;
	                    }
	                }
	            }
	        }
	        return result;
	    }
	};
	```
* 最长回文子序列：不连续，求最长的长度。
		
		dp[i][j]：[i, j]范围内的子串，最长回文子序列长度为dp[i][j]。
		if (s[i] == s[j]) {dp[i][j] = dp[i + 1][j - 1] + 2;}
		else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1], dp[i + 1][j - 1]);
		
		起始位置从135°斜线开始，所以要这样初始化
		for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
		
		解法二：这题也可用两个字符串的最长公共子序列长度的思路来解，str, str.reverse()
	```cpp
	class Solution {
	public:
	    int longestPalindromeSubseq(string s) {
	        // dp[i][j]：[i, j]范围内的子串，最长回文子序列长度为dp[i][j]。
	        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
	        // 起始位置从135°斜线开始，所以要这样初始化
	        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
	        for (int i = s.size() - 1; i >= 0; i--) {
	            for (int j = i + 1; j < s.size(); j++) {
	                if (s[i] == s[j]) {
	                    dp[i][j] = dp[i + 1][j - 1] + 2;
	                }
	                else dp[i][j] = max(dp[i + 1][j], max(dp[i][j - 1], dp[i + 1][j - 1]));
	            }
	        }
	        return dp[0][s.size() - 1];
	    }
	};
	```
